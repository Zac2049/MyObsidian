
>面经中总结各类问题，再寻找完整答案
- go的底层实现
## go channel
Go语言中的Channel本质上是一种类型，它可以看作是一个先进先出的队列。当一个协程向Channel发送数据时，该数据被添加到队列的尾部；当另一个协程从Channel接收数据时，该数据被从队列的头部删除。Channel可以保证数据的顺序性和原子性，因此可以实现高效的并发通信。
Channel的底层实现结构是一个结构体类型，`runtime.hchan`。每个Channel都对应一个`hchan`对象，它包含了Channel的状态信息和实现所需的各种数据结构。
```go
type hchan struct { 
	qcount uint // 队列中的元素数量 
	dataqsiz uint // 队列的容量 
	buf unsafe.Pointer // 队列中的元素 
	elemsize uint16 // 每个元素的大小 
	closed uint32 // 标记该Channel是否已关闭 
	recvx uint // 下一个要接收的元素的索引 
	sendx uint // 下一个要发送的元素的索引 
	recvq waitq // 等待接收的协程队列 
	sendq waitq // 等待发送的协程队列 
	lock mutex // Channel的锁 
}
```
`runtime.hchan`包括元素的数量、队列的容量、元素大小，指向元素的指针，`recvq`和`sendq`字段分别对应等待接收和发送的协程队列。当一个协程要发送数据时，它会将自己添加到`sendq`队列中，然后阻塞等待；当一个协程要接收数据时，它会将自己添加到`recvq`队列。当有另一个协程向Channel中发送或接收数据时，它会从相应的队列中取出一个等待的协程并唤醒它。
Channel的发送和接收操作都是原子的，因此需要使用互斥锁。

## go map
Map的底层实现基于散列表（hash table），并且在键的类型为可比较类型（comparable type）的情况下，使用开放地址法（open addressing）作为冲突解决策略。
```go
type hmap struct { 
	count int // 当前Map中元素的数量 
	flags uint8 // Map的状态标记 
	B uint8 // 散列表的初始桶数，即散列表中的槽数 
	noverflow uint16 // 发生扩容的次数 
	hash0 uint32 // 哈希种子，用于散列键值 
	buckets unsafe.Pointer // 指向散列表桶数组的指针 
	oldbuckets unsafe.Pointer // 旧桶数组的指针，用于扩容时数据迁
	nevacuate uintptr // 扩容时需要迁移的数据数量 
	extra *mapextra // 用于存储键/值类型信息等额外信息的指针 
}
```
上述结构体中，`buckets`是一个指向散列表桶数组的指针，`count`是当前Map中元素的数量。Map中的键和值都保存在桶中，桶是一个**链表结构**，每个桶中保存了散列值相同的键值对。

Map的扩容机制是当Map中元素的数量达到散列表的负载因子时（默认为6.5），就会自动扩容。Map的扩容过程比较复杂，大致分为以下几步：
```golang
loadFactor := count / (2^B)
```

count 就是 map 的元素个数，2^B 表示 bucket 数量。

1.  计算扩容后的桶数，并创建新的桶数组。新桶数组的大小为当前桶数的两倍，但最小不能低于初始桶数`B`。
    
2.  为新桶数组中的每个桶分配一块内存，并将其初始化为空链表。
    
3.  遍历旧桶数组中的每个桶，将其中的元素逐个插入到新桶数组中对应的桶中。实际采用“渐进式”的方式，原有的 key 并不会一次性搬迁完毕，每次最多只会搬迁 2 个 bucket在插入过程中，如果发现新桶数组中对应的桶中已经有元素了，则将其插入到该桶的链表尾部。。
    
4.  释放旧桶数组中的内存，并将指针指向新桶数组。
    

在Map的扩容过程中，由于需要遍历整个散列表，将元素逐个插入到新桶中，所以需要一定的时间和内存开销。同时，在扩容过程中，Map的访问会被暂停，因此需要尽量避免在高并发场景下频繁

哈希查找表（Hash table），实现包括：AVL 树，红黑树。

- AVL树和红黑树
红黑树是一种自平衡二叉搜索树，它的平衡操作相比AVL树更加灵活，因此应用更为广泛。红黑树中每个节点都是红色或黑色的，并满足以下规则：

1.  根节点是黑色的。
2.  每个叶子节点（NULL节点）都是黑色的。
3.  如果一个节点是红色的，则其子节点必须是黑色的。
4.  从任意一个节点到其子树中每个叶子节点的路径都包含相同数目的黑色节点。

这些规则保证了红黑树的高度不会超过2log(n+1)，其中n为节点数。

在红黑树中，插入和删除操作也会引起树的不平衡，需要进行平衡操作。平衡操作包括旋转和颜色变换，旋转有左旋和右旋两种，颜色变换有颜色翻转和颜色调整两种。平衡操作的目的是保证树的每个节点满足上述规则，以保证树的平衡。

红黑树和AVL树都是自平衡二叉搜索树，但是它们的平衡策略略有不同。

首先，红黑树对节点的颜色进行了限制，使得每个节点不仅有值，还有颜色属性。这个颜色属性可以为红色或黑色。这样，红黑树的平衡操作就可以通过改变节点的颜色来达到，不像AVL树那样只能通过旋转来平衡。

其次，红黑树的平衡策略比AVL树稍微宽松一些，因此红黑树的平衡操作比AVL树的操作更加简单，效率也更高。红黑树的最大高度是2log(n+1)，而AVL树的最大高度是log(n)，因此红黑树的性能在某些特定情况下可能比AVL树更好，比如对于数据量较大的情况。

红黑树相比AVL树的主要优点：

1.  红黑树的插入、删除、旋转等操作比AVL树简单，因此效率更高，对于大型数据的操作更加优秀。
2.  红黑树的平衡性能相对较好，保证了树的高度较小，从而保证了查找、插入、删除等操作的时间复杂度为O(logn)。

红黑树相比AVL树的主要缺点：

1.  在某些特定的应用场景下，AVL树的查询性能可能比红黑树更好。
2.  由于红黑树的平衡性能较好，相比AVL树需要额外的空间来存储节点的颜色属性，因此占用的内存空间稍大。

- map是线程安全的吗
Map在并发环境下并不是线程安全的，因为Map的底层实现是基于散列表的，当多个协程同时对Map进行操作时，可能会导致散列表中的元素出现冲突或者损坏。这个问题可以通过对Map进行加锁来解决，但这会降低并发性能。

在Go语言中，为了在并发环境下安全地使用Map，可以使用内置的同步机制——互斥锁（Mutex）或读写锁（RWMutex）。使用互斥锁可以保证在同一时间只有一个协程能够访问Map，从而避免了并发冲突的问题。使用读写锁可以进一步提高性能，因为在多个协程同时读取Map时，可以允许并发访问。

- sync.map为什么并发安全
sync.Map是Go语言提供的一种线程安全的Map，可以在并发环境下安全地使用，而不需要使用互斥锁或读写锁等同步机制。这是因为sync.Map内部使用了一种特殊的并发安全的数据结构，称为“分片锁（sharded lock）”。

在sync.Map内部，数据被分成了若干个块（shard），每个块都有自己的锁。当对Map进行读写操作时，会根据键的哈希值选择一个块，并对该块的锁进行加锁，从而保证只有一个协程可以访问该块。这样就避免了整个Map的锁竞争，大大提高了并发性能。

在分片锁的实现中，sync.Map使用了类似于哈希表的算法来将键映射到块上。具体来说，sync.Map使用了一个叫做“伪随机哈希函数（pseudorandom hash function）”的函数来计算键的哈希值，并根据哈希值将键分配到对应的块中。同时，sync.Map还会动态地调整块的数量，以适应并发负载的变化，从而提高并发性能。

需要注意的是，虽然sync.Map是线程安全的，但它并不保证对Map的操作是原子的。因此，在对Map进行一系列复合操作时，仍然需要使用互斥锁或读写锁来保证原子性。




- `Lock()`和`RLock()`的区别
	- [go - what is the difference between RLock() and Lock() in Golang? - Stack Overflow](https://stackoverflow.com/questions/53427824/what-is-the-difference-between-rlock-and-lock-in-golang)
	- [读写锁和互斥锁的性能比较 | Go 语言高性能编程 | 极客兔兔 (geektutu.com)](https://geektutu.com/post/hpg-mutex.html)
- nil切片和空切片的区别
	-  nil切片和空切片指向的地址不一样。nil空切片引用数组指针地址为0（无指向任何实际地址）
	-   空切片的引用数组指针地址是有的，且固定为一个值
- 字符串转成切片，会产生拷贝。严格来说，只要是发生类型强转都会发生内存拷贝。
	- 把 `StringHeader` 的地址强转成 `SliceHeader` 就行。
-  `rune`关键字，从golang源码中看出，它是int32的别名（-2^31 ~ 2^31-1），比起byte（-128～127），可表示更多的字符。
- 拷贝大切片跟小切片的代价应该是一样的。
- `json`包里使用的时候，结构体里的变量不加`tag`能不能正常转成`json`里的字段？
	-    如果变量`首字母小写`，则为`private`。无论如何`不能转`，因为取不到`反射信息`。
	-   如果变量`首字母大写`，则为`public`。
		-   `不加tag`，可以正常转为`json`里的字段，`json`内字段名跟结构体内字段`原名一致`。
		-   `加了tag`，从`struct`转`json`的时候，`json`的字段名就是`tag`里的字段名，原字段名已经没用。
- 能说说uintptr和unsafe.Pointer的区别吗？
	-   unsafe.Pointer只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；
	-   而uintptr是用于指针运算的，GC 不把 uintptr 当指针，也就是说 uintptr 无法持有对象， uintptr 类型的目标会被回收；
	-   unsafe.Pointer 可以和 普通指针 进行相互转换；
	-   unsafe.Pointer 可以和 uintptr 进行相互转换
- `for`循环`select`时，如果通道已经关闭会怎么样？如果`select`中的`case`只有一个，又会怎么样？
	-   for循环`select`时，如果其中一个case通道已经关闭，则每次都会执行到这个case。
	-   如果select里边只有一个case，而这个case被关闭了，则会出现死循环。
- 对已经关闭的的 `chan` 进行读写，会怎么样？为什么？
	- 读已经关闭的 `chan` 能一直读到东西，但是读到的内容根据通道内`关闭前`是否有元素而不同。
	-   如果 `chan` 关闭前，`buffer` 内有元素**还未读** , 会正确读到 `chan` 内的值，且返回的第二个 bool 值（是否读成功）为 `true`。
	-   如果 `chan` 关闭前，`buffer` 内有元素**已经被读完**，`chan` 内无值，接下来所有接收的值都会非阻塞直接成功，返回 `channel` 元素的**零值**，但是第二个 `bool` 值一直为 `false`。
	-   写**已经关闭**的 `chan` 会 `panic`
- slice扩容机制
	- 这个公式，对于容量小的切片，按照2倍的速率扩容和对于容量大的切片，按照1.25倍的速度扩容，为两者提供了平滑的过渡。
- **线程是独立调度的基本单位，进程是资源拥有的基本单位**。**用户级线程即协程**，由应用程序创建与管理，协程必须与内核级线程绑定之后才能执行。
	- 线程有一些公共信息，例如**数据段、代码段、文件**等，这些信息共享给它们的对等线程。但包含自己的**寄存器**、**堆栈**和**程序计数器**。
		**堆栈**：函数在被执行的时候产生的数据包括 **函数参数**、 **局部变量**、 **返回地址**等信息，这些信息是保存在栈中的，线程相当于进程中的一个执行流，为了保存执行流的信息，我们需要给线程创建独属堆栈
		
		**寄存器**：函数运行需要额外的寄存器来保留一些信息，所以线程的寄存器也是私有的。
		
		**程序计数器**：CPU 执行指令的信息保存在一个叫做程序计数器的寄存器中，通过这个寄存器我们就知道接下来要执行哪一条指令。所以线程也有自己的计数器用于告诉我们线程执行的工作顺序。
	- 协程可以看作轻量级线程，他的内存占用少只要 2k，且上下文切换成本低，是一个独立执行的函数，由 go 语言启动，由 Go 运行时（runtime）管理。Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。
	- <iframe 
		border=0
		frameborder=0
		height=550
		width=850
		src="https://xie.infoq.cn/article/6f306c7113545609a2cb75231"></iframe>
		
	- <iframe 
		border=0
		frameborder=0
		height=550
		width=850
		src="https://blog.51cto.com/u_13280061/3163129#%E5%90%8C%E4%B8%80%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%85%B1%E4%BA%AB%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%EF%BC%9F"></iframe>
- GMP调度流程大致如下：

	-   线程M想运行任务就需得获取 P，即与P关联。
	    
	-   然从 P 的本地队列(LRQ)获取 G
	    
	-   若LRQ中没有可运行的G，M 会尝试从全局队列(GRQ)拿一批G放到P的本地队列，
	    
	-   若全局队列也未找到可运行的G时候，M会随机从其他 P 的本地队列偷一半放到自己 P 的本地队列。
	    
	-   拿到可运行的G之后，M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。
- <iframe 
		border=0
		frameborder=0
		height=550
		width=850
		src="https://www.zhihu.com/question/447947474"></iframe>
- 获取长string或者切片中的一段内容，由于新生成的对象和老的string或者切片共用一个内存空间，会导致老的string和切片资源暂时得不到释放，造成短暂的内存泄漏
- 浏览器寻址url过程？
	- [浏览器从输入网址到页面展示的过程 - 腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1879758)
- <iframe 
		border=0
		frameborder=0
		height=550
		width=850
		src="https://cloud.tencent.com/developer/article/1879758"></iframe>
-  go 打印时 %v %+v %#v 的区别?
	- %v 只输出所有的值；
	- %+v 先输出字段名字，再输出该字段的值；
	- %#v 先输出结构体名字值，再输出结构体（字段名字+字段的值）；
-  CSP并发模型
	不同于传统的多线程通过共享内存来通信，CSP讲究的是“以通信的方式来共享内存”。用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。 CSP中channel是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的channel。
	大多数的编程语言的并发编程模型是基于线程和内存同步访问控制，Go 的并发编程的模型则用 goroutine 和 channel 来替代。Goroutine 和线程类似，channel 和 mutex (用于内存同步访问控制)类似。
- linux下查看某一端口被哪个进程占用、
	lsof命令,即ls open files
	lsof -i:端口号
- linux查看磁盘占用率
	df -h和du -sh使用的比较多，一个统计整体磁盘情况，一个看单独目录点用情况
- linux文件类型
 <iframe 
	border=0
	frameborder=0
	height=550
	width=850
	src="https://www.360blogs.top/linux-file-type/"></iframe>
- get和post请求的区别
	GET请求只能进行url编码，而POST支持多种编码方式。GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。GET请求在URL中传送的参数是有长度限制的，而POST么有。对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- go单元测试规范
	- 文件包名`package xxx_test`
	- 方法名`func TestXxx()`
	- 方法参数`t *testing.T`
- go实现面对对象
	- Embedding实现继承
	- 借助interface实现多态
- GC 触发的场景主要分为两大类，分别是：
1.  系统触发：运行时自行根据内置的条件，检查、发现到，则进行 GC 处理，维护整个应用程序的可用性。
2.  手动触发：开发者在业务代码中自行调用 `runtime.GC` 方法来触发 GC 行为。
 **系统触发**
在系统触发的场景中，Go 源码的 `src/runtime/mgc.go` 文件，明确标识了 GC 系统触发的三种场景，分别如下：

```go
const (
 gcTriggerHeap gcTriggerKind = iota
 gcTriggerTime
 gcTriggerCycle
)
```

-   gcTriggerHeap：当所分配的堆大小达到阈值（由控制器计算的触发堆的大小）时，将会触发。
-   gcTriggerTime：当距离上一个 GC 周期的时间超过一定时间时，将会触发。-时间周期以 `runtime.forcegcperiod` 变量为准，默认 2 分钟。
-   gcTriggerCycle：如果没有开启 GC，则启动 GC。
    -   在手动触发的 `runtime.GC` 方法中涉及。

- 查看硬件信息
	- `cat /proc/cpuinfo`
	- `env`
- 用 for-range 来读取 channel的数据，for-range 是一个很有特色的语句，有以下特点：
	-   如果 channel 已经被关闭，它还是会继续执行，直到所有值被取完，然后退出执行
	-   如果通道没有关闭，但是channel没有可读取的数据，它则会阻塞在 range 这句位置，直到被唤醒。
	-   如果 channel 是 nil，那么同样符合我们上面说的的原则，读取会被阻塞，也就是会一直阻塞在 range 位置。
- map原理
	- 最主要的数据结构有两种：`哈希查找表（Hash table）`、`搜索树（Search tree）`。
	- 哈希查找表用一个哈希函数将 key 分配到不同的桶（bucket，也就是数组的不同 index）。
	- 哈希查找表一般会存在“碰撞”的问题，就是说不同的 key 被哈希到了同一个 bucket。一般有两种应对方法：`链表法`和`开放地址法`。`链表法`将一个 bucket 实现成一个链表，落在同一个 bucket 中的 key 都会插入这个链表。`开放地址法`则是碰撞发生后，通过一定的规律，在数组的后面挑选“空位”，用来放置新的 key。
	- Go 语言采用哈希查找表，并且使用链表解决哈希冲突。
	- `bmap` 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置。
	- map 并不是一个线程安全的数据结构。同时读写一个 map 是未定义的行为，如果被检测到，会直接 panic。
- Golang的Channel,发送一个数据到Channel 和从Channel接收一个数据都是原子性的。这个可以看源码就知道channel内部维护了一个互斥锁，来保证线程安全。
- 交叉编译是**在一个平台上生成另一个平台上的可执行代码**
- sync.map
<iframe 
	border=0
	frameborder=0
	height=550
	width=850
	src="https://qcrao.com/post/dive-into-go-sync-map/"></iframe>

- utf-8与unicode的区别
	- ascii和unicode都是字符集
	- utf-8是关于unicode的编码。UTF-8 代表 8 位一组表示 Unicode 字符的格式，使用 1 - 4 个字节来表示字符。UTF-8 通过开头的标志位位数实现了变长。对于单字节字符，只占用一个字节，实现了向下兼容 ASCII，并且能和 UTF-32 一样，包含 Unicode 中的所有字符，又能有效减少存储传输过程中占用的空间。
-  URLencode
	- 中文不在ASCII字符中，因此中文出现在URL地址中时，需要进行编码；同时可书写的ASCII字符中，存在一些`不安全字符`也需要转码，如`空格`
- 计算机是如何存小数的
	- 计算机通常使用浮点数来存储小数。
	- 计算机使用IEEE 754标准来定义浮点数的二进制格式。具体而言，单精度浮点数（32位）使用1位符号位、8位指数位和23位尾数位，双精度浮点数（64位）使用1位符号位、11位指数位和52位尾数位。
- http和https的区别 你能具体说说https加密的过程吗

- 怎么用 go 来做并发和同步，用过 sync 包里的哪些东西
	- sync 包中的 WaitGroup 来等待所有的 goroutine 完成。包括wg.add(), wg.done(), wg.wait()
	- 除了 WaitGroup 外，sync 包还提供了其他用于同步的工具，例如 Mutex（互斥锁）、Cond（条件变量）和 Once（一次性执行）。其中，Mutex 用于控制对共享资源的访问，Cond 用于等待或通知某个条件的变化，Once 用于只执行一次的操作。这些工具都可以有效地帮助我们处理并发和同步的问题。
- go垃圾回收
Go语言的垃圾回收器采用的是**标记清除算法**。它通过遍历堆中的所有对象，并标记那些仍然在使用的对象。然后，它会将没有被标记的对象从堆中清除出去，以释放内存空间。Go语言的垃圾回收器还实现了三色标记算法，这种算法在标记对象时效率更高，可以减少垃圾回收的时间。

在Go语言中，内存是以页的形式分配的。当程序需要内存时，Go语言的运行时系统会向操作系统申请一些页来存储对象。这些页会被分为小的内存块，每个内存块通常是16字节或32字节大小。当程序需要分配一个新的对象时，运行时系统会在空闲列表中查找一个足够大的内存块，然后将其分配给对象。

Go语言的垃圾回收器是并发的，它可以在程序运行时持续地回收垃圾对象，而不会阻塞程序的执行。当垃圾回收器在进行回收时，程序会继续执行，但可能会出现一些短暂的暂停。

Go语言还提供了一些与内存管理相关的函数和包，例如sync.Pool、runtime.MemStats等。sync.Pool是一个对象池，可以用来重复利用一些对象，以减少垃圾回收的压力。runtime.MemStats包含了一些关于内存使用情况的统计信息，可以用来分析程序的内存使用情况。

- golang写屏障
写屏障是指在写入指向堆对象的指针时插入的特殊代码，它用于确保指针在垃圾回收期间被正确处理。具体来说，当一个指针被写入时，写屏障会将其标记为“脏”，表示这个指针被修改过。垃圾回收器在扫描指针时会检查这个标记，并确保正确地扫描脏指针指向的对象。这样可以确保垃圾回收器在并发执行时能够正确处理指针，避免出现并发错误。

见下
<iframe 
	border=0
	frameborder=0
	height=550
	width=850
	src="https://xie.infoq.cn/article/ac87ac5f9e8def9f91b817bf9"></iframe>
