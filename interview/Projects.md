## 小型web框架
主要借鉴Gin
- `net/http`提供了基础的Web功能，即监听端口，映射静态路由，解析HTTP报文
- 整体的这个处理请求给出响应的主体，定为Engine这个struct，处理用户的GET的行为就是这个Engine的方法，监听端口并运行
- 对客户端的请求，服务端都得给出一个handler方法，封装handler的端口，自定义一个Context封装Request和ResponceWriter，Context也对
- 将router和handler的映射从分离出来，并增加routerGroup，对不同组的group采用不同的中间件，以及实现动态路由，动态路由具体采用Trie树实现，Trie树更具体是用指针数组实现的
- 中间件的实现，具体是在context下面增加middleware的handler，再增加use方法，服务端执行中间件的时候，调用这个use就行
- 还有就是一些细节，比如logger，template渲染模板

## 分布式缓存
主要借鉴groupcache
- 核心数据结构Group负责与用户的交互，并且控制缓存值存储和获取的流程，可以认为是一个缓存的命名空间。缓存不存在时，需要在本地回调时，调用回调函数，这里抽象出接口getter，本地不存在就从远程获取节点，具体采用http服务
- 手动实现LRU内存淘汰机制，具体由map和双向链表实现，淘汰队首，插入和访问时放至队尾，抽象byteView表示缓存值，之后对cache实现的修改操作进行加锁
- 简单的哈希映射没有考虑节点数量变化的场景。当节点数量变化时，几乎缓存值对应的节点都发生了改变，即几乎所有的缓存值都失效了，造成瞬时DB请求量大，即缓存雪崩。
- 引入一致性哈希。映射空间是固定的2^32，形成一个环。首先节点都放置在环上，key映射在环上的某个值，顺时针寻找第一个节点，就是其对应节点
- 数据倾斜，即节点分布比较集中，这时将映射关系从真实节点改到虚拟节点即可
- 数据击穿，相同一个端口发送大量请求，主要使用waitgroup解决，具体需要抽象出singleflight
- 缓存穿透：查询一个不存在的数据

## 频域分割网络

- encoder， decoder
- 采取ViT的分块加位置编码
- 分别四个块，每个块都会对图像进行FFT，对频域图进行和一个有参数量的矩阵做乘法，再iFFT，LN
- 为什么有效？
	1. 卷积定理，两个函数或者信号在时域中的卷积等价于频域中的相乘（逐点相乘）
	2. 连续傅里叶到离散傅里叶
	3. 快速傅里叶，利用傅里叶变换后频域信息的对称和周期性，从$O(n^2)$到$O(nlogn)$

- 在计算机中，可以使用一个长度为N的数组来表示DFT的频域序列，数组中的每个元素表示一个频率分量的幅度和相位。